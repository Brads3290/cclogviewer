package processor

import (
	"encoding/json"
	"github.com/Brads3290/cclogviewer/internal/models"
	"log"
	"strings"
	"time"
)

// ProcessEntries processes raw log entries into a structured format
func ProcessEntries(entries []models.LogEntry) []*models.ProcessedEntry {
	// Initialize state
	state := &ProcessingState{
		Entries:        make([]*models.ProcessedEntry, 0, len(entries)),
		ToolCallMap:    make(map[string]*ToolCallContext),
		ParentChildMap: make(map[string][]string),
	}

	// Create entry map for quick lookup
	entryMap := make(map[string]*models.ProcessedEntry)

	// Phase 1: Process all entries
	for i, entry := range entries {
		state.Index = i
		processed := processEntry(entry)
		entryMap[processed.UUID] = processed
		state.Entries = append(state.Entries, processed)
	}

	// Phase 2: Match tool calls with results
	matcher := NewToolCallMatcher()
	if err := matcher.MatchToolCalls(state); err != nil {
		log.Printf("Error matching tool calls: %v", err)
	}

	// Filter to get root entries
	rootEntries := matcher.FilterRootEntries(state.Entries)

	// Phase 3: Process sidechains
	sidechainProc := NewSidechainProcessor()
	if err := sidechainProc.ProcessSidechains(state.Entries, entries, entryMap); err != nil {
		log.Printf("Error processing sidechains: %v", err)
	}

	// Phase 4: Calculate tokens
	for _, entry := range rootEntries {
		calculateTokensForEntry(entry)
	}

	// Phase 5: Check for missing results
	for _, entry := range rootEntries {
		checkMissingToolResults(entry)
	}

	// Phase 6: Link command outputs
	linkCommandOutputs(rootEntries)

	// Phase 7: Build hierarchy and set depths
	hierarchy := NewHierarchyBuilder()
	if err := hierarchy.BuildHierarchy(rootEntries); err != nil {
		log.Printf("Error building hierarchy: %v", err)
	}

	return rootEntries
}

// checkMissingToolResults recursively checks for missing tool results and sidechains
func checkMissingToolResults(entry *models.ProcessedEntry) {
	// Check tool calls in this entry
	for i := range entry.ToolCalls {
		toolCall := &entry.ToolCalls[i]

		// Check if result is missing
		if toolCall.Result == nil {
			toolCall.HasMissingResult = true
		}

		// For Task tools, also check if sidechain is missing
		if toolCall.Name == "Task" && len(toolCall.TaskEntries) == 0 {
			toolCall.HasMissingSidechain = true
		}

		// Recursively check Task entries
		for _, taskEntry := range toolCall.TaskEntries {
			checkMissingToolResults(taskEntry)
		}
	}

	// Recursively check children
	for _, child := range entry.Children {
		checkMissingToolResults(child)
	}
}

// calculateTokensForEntry recursively calculates tokens for an entry and all its nested tool calls
func calculateTokensForEntry(entry *models.ProcessedEntry) {
	entry.TotalTokens = entry.InputTokens + entry.CacheReadTokens + entry.CacheCreationTokens

	// Calculate for tool calls
	for i := range entry.ToolCalls {
		toolCall := &entry.ToolCalls[i]

		// Calculate for tool result
		if toolCall.Result != nil {
			toolCall.Result.TotalTokens = toolCall.Result.InputTokens +
				toolCall.Result.CacheReadTokens + toolCall.Result.CacheCreationTokens
		}

		// Recursively calculate for nested Task entries
		for _, taskEntry := range toolCall.TaskEntries {
			calculateTokensForEntry(taskEntry)
		}
	}
}

func processEntry(entry models.LogEntry) *models.ProcessedEntry {
	processed := &models.ProcessedEntry{
		UUID:         entry.UUID,
		IsSidechain:  entry.IsSidechain,
		Type:         entry.Type,
		Timestamp:    formatTimestamp(entry.Timestamp),
		RawTimestamp: entry.Timestamp,
	}

	if entry.ParentUUID != nil {
		processed.ParentUUID = *entry.ParentUUID
	}

	// Process the message content
	var msg map[string]interface{}
	if err := json.Unmarshal(entry.Message, &msg); err == nil {
		processed.Role = GetStringValue(msg, "role")

		// Handle different message types
		switch processed.Type {
		case "user":
			processed.Content = ProcessUserMessage(msg)
			processed.IsToolResult = isToolResult(msg)

			// Check if this is a caveat message from local commands
			if strings.HasPrefix(processed.Content, "Caveat: The messages below were generated by the user while running local commands.") {
				processed.IsCaveatMessage = true
			}

			// Check if this is a command message with XML syntax
			if strings.Contains(processed.Content, "<command-name>") && strings.Contains(processed.Content, "</command-name>") {
				processed.IsCommandMessage = true
				// Parse command details
				processed.CommandName = extractXMLContent(processed.Content, "command-name")
				processed.CommandArgs = extractXMLContent(processed.Content, "command-args")
			}
		case "assistant":
			processed.Content, processed.ToolCalls = ProcessAssistantMessage(msg, entry.CWD)
		}

		// Check if it's an error and extract tool result ID
		if processed.IsToolResult {
			if content, ok := msg["content"].([]interface{}); ok && len(content) > 0 {
				if toolResult, ok := content[0].(map[string]interface{}); ok {
					processed.IsError = GetBoolValue(toolResult, "is_error")
					processed.ToolResultID = GetStringValue(toolResult, "tool_use_id")
				}
			}
		}

		// Extract token counts from usage field if available
		if usage, ok := msg["usage"].(map[string]interface{}); ok {
			// Extract all token types
			if inputTokens, ok := usage["input_tokens"].(float64); ok {
				processed.InputTokens = int(inputTokens)
			}
			// Always estimate output tokens from content for accuracy
			processed.OutputTokens = EstimateTokens(string(processed.Content))
			processed.TokenCount = processed.OutputTokens

			if cacheReadTokens, ok := usage["cache_read_input_tokens"].(float64); ok {
				processed.CacheReadTokens = int(cacheReadTokens)
			}
			if cacheCreationTokens, ok := usage["cache_creation_input_tokens"].(float64); ok {
				processed.CacheCreationTokens = int(cacheCreationTokens)
			}
		} else {
			// Fall back to estimation for messages without usage data
			processed.TokenCount = EstimateTokens(string(processed.Content))
			// For user messages, the estimated tokens are output tokens
			if processed.Role == "user" {
				processed.OutputTokens = processed.TokenCount
			}
		}
	} else {
		// If we can't parse the message, estimate tokens from content
		processed.TokenCount = EstimateTokens(string(processed.Content))
	}

	return processed
}

func collectSidechainEntries(root *models.ProcessedEntry, entryMap map[string]*models.ProcessedEntry) []*models.ProcessedEntry {
	var result []*models.ProcessedEntry

	// First, collect all tool results that are attached to tool calls
	attachedToolResults := make(map[string]bool)
	for _, entry := range entryMap {
		if entry.IsSidechain {
			for _, toolCall := range entry.ToolCalls {
				if toolCall.Result != nil {
					attachedToolResults[toolCall.Result.UUID] = true
				}
			}
		}
	}

	// Build the sidechain tree structure
	var buildTree func(entry *models.ProcessedEntry, skipEntry bool)
	buildTree = func(entry *models.ProcessedEntry, skipEntry bool) {
		// Add to result only if we're not skipping this entry
		if !skipEntry {
			result = append(result, entry)
		}

		// Find and add children
		for _, e := range entryMap {
			if e.ParentUUID == entry.UUID && e.IsSidechain {
				entry.Children = append(entry.Children, e)
			}
		}

		// Recursively process children
		for _, child := range entry.Children {
			// Skip tool results that have been attached to tool calls when adding to result,
			// but still process their children
			shouldSkip := child.IsToolResult && attachedToolResults[child.UUID]
			buildTree(child, shouldSkip)
		}
	}

	buildTree(root, false)
	return result
}

func formatTimestamp(ts string) string {
	t, err := time.Parse(time.RFC3339, ts)
	if err != nil {
		return ts
	}
	return t.Format("15:04:05")
}

func isToolResult(msg map[string]interface{}) bool {
	if content, ok := msg["content"].([]interface{}); ok && len(content) > 0 {
		if toolResult, ok := content[0].(map[string]interface{}); ok {
			return GetStringValue(toolResult, "type") == "tool_result"
		}
	}
	return false
}

// GetStringValue extracts a string value from a map
func GetStringValue(m map[string]interface{}, key string) string {
	if val, ok := m[key].(string); ok {
		return val
	}
	return ""
}

// GetBoolValue extracts a bool value from a map
func GetBoolValue(m map[string]interface{}, key string) bool {
	if val, ok := m[key].(bool); ok {
		return val
	}
	return false
}

// extractContent extracts text content from a ProcessedEntry
func extractContent(entry *models.ProcessedEntry) string {
	// Content is now stored as raw text, no HTML processing needed
	return strings.TrimSpace(entry.Content)
}

// truncateString truncates a string to a maximum length
func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}

// extractFullSidechainContent extracts all text content from a sidechain conversation
func extractFullSidechainContent(root *models.ProcessedEntry, entryMap map[string]*models.ProcessedEntry) string {
	var content strings.Builder

	// Helper function to extract content from an entry and its children
	var extractFromEntry func(entry *models.ProcessedEntry)
	extractFromEntry = func(entry *models.ProcessedEntry) {
		// Add this entry's content
		entryText := extractContent(entry)
		if entryText != "" {
			content.WriteString(entryText)
			content.WriteString(" ")
		}

		// Process children
		for _, child := range entry.Children {
			extractFromEntry(child)
		}

		// Process any entries that have this as parent
		for _, e := range entryMap {
			if e.ParentUUID == entry.UUID && e.IsSidechain {
				// Check if it's already in children
				found := false
				for _, child := range entry.Children {
					if child.UUID == e.UUID {
						found = true
						break
					}
				}
				if !found {
					extractFromEntry(e)
				}
			}
		}
	}

	extractFromEntry(root)
	return content.String()
}

// getFirstUserMessage finds the first user message in a sidechain conversation
func getFirstUserMessage(root *models.ProcessedEntry, entryMap map[string]*models.ProcessedEntry) string {
	// First check if root itself is a user message
	if root.Role == "user" {
		return extractContent(root)
	}

	// Otherwise, look for the first user message in the tree
	var findFirstUser func(entry *models.ProcessedEntry) string
	findFirstUser = func(entry *models.ProcessedEntry) string {
		// Check children first (in order)
		for _, child := range entry.Children {
			if child.Role == "user" {
				return extractContent(child)
			}
		}

		// Then recursively check children's children
		for _, child := range entry.Children {
			if result := findFirstUser(child); result != "" {
				return result
			}
		}

		// Also check entries that have this as parent
		for _, e := range entryMap {
			if e.ParentUUID == entry.UUID && e.IsSidechain && e.Role == "user" {
				return extractContent(e)
			}
		}

		return ""
	}

	return findFirstUser(root)
}

// getLastAssistantMessage finds the last assistant message in a sidechain conversation
func getLastAssistantMessage(root *models.ProcessedEntry, entryMap map[string]*models.ProcessedEntry) string {
	var lastAssistantContent string
	var lastAssistantTime time.Time

	var findLastAssistant func(entry *models.ProcessedEntry)
	findLastAssistant = func(entry *models.ProcessedEntry) {
		// Check if this is an assistant message
		if entry.Role == "assistant" && !entry.IsToolResult {
			// Parse timestamp
			if t, err := time.Parse(time.RFC3339, entry.RawTimestamp); err == nil {
				if lastAssistantContent == "" || t.After(lastAssistantTime) {
					lastAssistantContent = extractContent(entry)
					lastAssistantTime = t
				}
			}
		}

		// Check children
		for _, child := range entry.Children {
			findLastAssistant(child)
		}

		// Check entries that have this as parent
		for _, e := range entryMap {
			if e.ParentUUID == entry.UUID && e.IsSidechain {
				// Avoid infinite recursion by checking if already in children
				found := false
				for _, child := range entry.Children {
					if child.UUID == e.UUID {
						found = true
						break
					}
				}
				if !found {
					findLastAssistant(e)
				}
			}
		}
	}

	findLastAssistant(root)
	return lastAssistantContent
}

// extractTaskPrompt extracts the prompt from a Task tool call's raw input
func extractTaskPrompt(toolCall *models.ToolCall) string {
	if toolCall.RawInput == nil {
		return ""
	}

	inputMap, ok := toolCall.RawInput.(map[string]interface{})
	if !ok {
		return ""
	}

	prompt, ok := inputMap["prompt"].(string)
	if !ok {
		return ""
	}

	return prompt
}

// normalizeText normalizes text for comparison by removing extra whitespace and newlines
func normalizeText(text string) string {
	// Replace all newlines with spaces
	text = strings.ReplaceAll(text, "\n", " ")
	text = strings.ReplaceAll(text, "\r", " ")

	// Replace multiple spaces with single space
	text = strings.Join(strings.Fields(text), " ")

	return strings.TrimSpace(text)
}

// extractXMLContent extracts content between XML tags
func extractXMLContent(text, tag string) string {
	startTag := "<" + tag + ">"
	endTag := "</" + tag + ">"

	startIdx := strings.Index(text, startTag)
	if startIdx == -1 {
		return ""
	}
	startIdx += len(startTag)

	endIdx := strings.Index(text[startIdx:], endTag)
	if endIdx == -1 {
		return ""
	}

	return text[startIdx : startIdx+endIdx]
}

// linkCommandOutputs links stdout messages to their preceding command messages
func linkCommandOutputs(entries []*models.ProcessedEntry) {
	for i := 0; i < len(entries)-1; i++ {
		current := entries[i]
		next := entries[i+1]

		// If current is a command message and next contains stdout
		if current.IsCommandMessage && next.Role == "user" &&
			strings.Contains(next.Content, "<local-command-stdout>") {
			// Extract the stdout content
			current.CommandOutput = extractXMLContent(next.Content, "local-command-stdout")
			// Mark the next entry for removal
			next.Content = ""
		}
	}
}

// setEntryDepth recursively sets the depth for entries based on sidechain hierarchy
func setEntryDepth(entry *models.ProcessedEntry, depth int) {
	// Set the depth for this entry
	entry.Depth = depth

	// Process all tool calls
	for i := range entry.ToolCalls {
		toolCall := &entry.ToolCalls[i]

		// If this is a Task tool with sidechain entries, set their depth to current depth + 1
		if toolCall.Name == "Task" && len(toolCall.TaskEntries) > 0 {
			for _, taskEntry := range toolCall.TaskEntries {
				setEntryDepth(taskEntry, depth+1)
			}
		}

		// Also set depth for tool results
		if toolCall.Result != nil {
			toolCall.Result.Depth = depth
		}
	}

	// Process children (though main conversation entries shouldn't have children)
	for _, child := range entry.Children {
		setEntryDepth(child, depth)
	}
}
